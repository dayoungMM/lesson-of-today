## equals 재정의 하지 않는게 좋은 경우 == Object의 equals로 충분

- 각 인스턴스가 본질적으로 고유할 때 (ex: Thread)
- 인스턴스의 논리적 동치성(Logical equality)를 검사할 일이 없는 경우
- 상위클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없는경우
- 같은 인스턴스가 2개 이상 만들어지지 않은 경우

## equals를 재정의 해야할 때

- 객체 식별성(object identity)이 아니라 논리적 동치성을 확인해야할 때

## equals 메서드는 동치관계를 구현하며 다음을 만족

- 동치관계: 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산
- 반사성(reflexivity): 객체 자기 자신과 같아야 한다
- 대칭성: 두 객체는 서로에 대한 동치여부에 똑같이 답해야 한다
- 추이성: 첫번째 객체와 두번째 객체가 같고, 두번째 객체가 세번째 객체와 같다면 첫번째 객체와 세번째 객체도 같아야 한다.
- 일관성: 두 객체가 같다면 끝까지 같아야한다
- null 아님

## equals 규약을 지키며 값 확장하기

- 클래스를 확장해 새로운 값을 추가하면서 기존의 equals 메서드를 상속하며 규약을 만족시킬 수 X
- 상속 대신 컴포지션 사용

## equals 구현

- ==연산자를 사용해 입력이 자기 자신의 참조인지 확인
- instanceof 연산자로 입력이 올바른 타입인지 확인
- 입력을 올바른 타입으로 형변환
- 입력 객체와 자기 자신의 다응되는 핵심 필드들이 모두 일치하느지 하나씩 검사
- equals를 재정의할 땐 hashCode도 반드시 재정의

## 비교 메서드

- ==: float double을 제외한 기본타입 필드 비교
- equals : 참조 타입 필드
- float, double필드 → 정적 메서드인 Float.compare(float, float) 등으로 비교