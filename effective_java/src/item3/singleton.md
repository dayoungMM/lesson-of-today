## 싱글톤(Singleton)

- 인스턴스를 오직 하나만 생성할 수 있는 패턴
- 클래스 싱글턴으로 만들경우 → 클라이언트가 테스트 하기 어려워질 수 있음 (moak 구현으로 대체 X)

## 싱글톤 패턴 사용이유

- 메모리
   - 최초 한번 new 연산자로 생긴 고정된 메모리 영역을 사용 → 메모리 낭비 방지
   - 이미 생성된 인스턴스 사용 → 속도 빠름
- 데이터 공유 쉬움
   - 전역으로 사용되는 인스턴스 → 다른 클래스에서 접근 가능

## 싱글톤 단점

- 여러 클래스의 인스턴스에서 싱글톤 인스턴스 데이터에 동시에 접근 → 동시성 문제 발생 가능
   - 동시성 문제 해결을 위해 syncronized 키워드 사용해야함
- 테스트 어려움
   - 격리된 환경에서 테스트하려면 매번 인스턴스 초기화 해줘야함 (전역에서 상태 공유하기 때문)
- 의존 관계
   - new 키워드 사용해서 클래스 안에서 객체를 생성하고 있음
   - DI 가 안됨

## 싱글톤 단점

-

## 방식

1. public static final 필드 방식
   - private 생성자는 public static final 필드를 초기화 할 때 딱 1번 호출됨
   - public 임으로 인스턴스가 전체 시스템에서 단 1개
   - 장점
      - 싱글턴인게 API에 명확히 드러남
      - 간결함
2. 정적 팩터리
   - 항상 같은 객체의 참조를 반환하므로 제2의 인스턴스 생성 X
   - 장점
      - API 바꾸지 않아도 싱글턴 아니게 변경가능 (return 할때 다른 인스턴스를 넘겨준다던가)
      - 정적 팩터리 → 제네릭 싱글턴 팩터리로 만들 수 있음
      - 정적 팩터리 메서드 참조를 공급자로 사용 가능
         - Elvis::getInstance → Supplier<Elvis>
3. enum 타입
   - 장점
      - 1번과 비슷하지만 더 간결
      - 직렬화 용이
      - 직렬화, 리플렉션 상황에서도 제2 인스턴스 생기는 일 없음
   - 단점
      - 싱글턴이 Enum 외의 클래스를 상속해야한다면 사용할 수 없음

## 싱글턴 클래스 직렬화 할 때 유의할 점

- 싱글턴임을 보장해주는 readResolve 메서드 선언하자
   - 안하면 인스턴스 deserialize 할 때마다 인스턴스 생김
   - 진짜 인스턴스는 반환하고, 가짜 인스턴스는 가비지 컬렉터에 맡김