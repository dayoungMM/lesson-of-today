# 8장 메서드
## Optional 클래스

- 예상치 못한 NullPointerException 예외를 제공되는 메소드로 간단히 회피하기 위해 등장
- null이 올 수 있는 값을 감싸는 Wrapper 클래스로, 참조하더라도 NPE가 발생하지 않도록 도와준다.
- orElse로 NullException 에러 대신 대안책을 제시할 수 있음

```java

public void findUserEmailOrElse() {
        String userEmail = "Empty";
				// 파라미터로 값을 받음
        String result = Optional.ofNullable(userEmail).orElse(getUserEmail());
        System.out.println(result);
    }

public void findUserEmailOrElseGet() {
    String userEmail = "Empty";
		//파라미터로 함수형 인터페이스를 받음
    String result = Optional.ofNullable(userEmail).orElseGet(this::getUserEmail);
    System.out.println(result);
}
```

## 1. 매개변수가 유효한지 검사하라

- 메서드나 생성자 작성시 매개변수에 어떤 제약이 있을지 생각해야 한다
- 유효하지 않을 때 던지는 예외를 문서화 하자
    - @throw 자바독 태그를 이용하던지
    - @Nullable같은 어노테이션을 이용하던지
- 매개변수 검사 메서드 예시
    - java.util.Objects.requireNonNull : null 검사 (자바 7 이상)
    - assert
        - 특정 조건을 실패하면 AssertionError를 던진다
- 유효성 검증 시점
    - 일반적으로 메서드 몸체 실행전
    - 하지만 유효성 검사 비용이 지나치게 높거나 실용적이지 않거나, 계산 과정에서 암묵적으로 검사될 때 예외

## 2. 적시에 방어적 복사본을 만들라

- 클라이언트가 불변식을 깨트릴려고 한다고 가정하고 방어적으로 코딩해야한다
- 방어적 복사본 만들 때 주의할 점
  - 생성자
    - 생성자에서 받은 가변 매개변수를 각각 방어적으로 복사
    - 매개변수 유효성 검사 하기 전에 방어적 복사본 만들어 놓기
  - 접근자
    - 접근자가 가변 필드의 방어적 복사본을 return 하도록 설정
- 결론
  - 자신 말고는 가변 필드에 접근할 수 없도록 캡슐화 해놓는 것이 불변식을 유지하기에 안전하다
  - 그러기 위해서는 방어적 복사본을 활용하자
  - 되도록 불변 객체를 조합해 객체 구성을 해야 방어적 복사를 할 일이 줄어든다

## 3. 메서드 시그니처를 신중히 설계하라

- 메서드 이름을 신중히 짓자 (일관적, 관련성)
- 편의 메서드를 너무 많이 만들지 말자
- 매개변수 목록은 짧게 유지하자
  - 여러메서드로 쪼개기 (직교성 높이기)
  - 매개변수 여러개를 묶어주는 도우미 클래스 사용
  - 빌더패턴을 메서드 호출에 응용 (setter 여러개, 마니지막에 execute 메서드 실행)
- 매개변수 타입으로는 클래스보다 인터페이스가 낫다.
- boolean보다는 원소 2개짜리 열거 타입이 낫다 (의미 명확)

## 4. 다중 정의는 신중하게 사용하라

### 4.1 다중정의를 피해야하는 이유

- 다중정의 메서드는 정적으로 선택되고, 재정의한 메서드는 동적으로 선택되어 실제 실행시 생각과 다를수도
- 이를 피하려면 instanceof로 명시적으로 검사하면 되지만, 혼동을 일으키는 상황 자체를 피하는게 바람직

### 4.2  다중 정의 대안책

- 메서드 이름을 다르게 지어주기 (static method 등)

### 4.3 그래도 사용해야할 경우 유의점

- 메서드별로 어느 것이 주어진 매개변수 집합을 처리할지 명확히 구분되게 정의하기
- 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받지 않기