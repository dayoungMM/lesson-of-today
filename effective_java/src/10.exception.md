# 10장 예외
## 1. 예외는 진짜 예외 상황에서만 사용

- 일상적인 제어 흐름용으로 사용하지 말자 == 정상적인 비즈니스 흐름이면 예외 발생할일 없음

## 2. 복구할 수 있는 상황→ 검사예외, 프로그래밍 오류 → 런타임 예외

- 예외 종류
    - 검사 예외 (Exception)
        - 호출하는 쪽에서 복구할 예정, 복구 가능
        - 복구에 필요한 정보를 알려주는 메서드도 제공하자
        - ex: 비밀번호는 5자리 이상이어야 한다는 메세지의 customized 예외
    - 런타임 예외 (RuntimeException)
        - 비검사 예외
        - 프로그래밍 오류
        - 전제조건을 지키지 못한경우
        - ex: ArrayIndexOutOfBoundsException
    - 에러 (Error)
        - 더이상 수행할 수 없음
        - ex: JVM 자원 부족, 불변식 깨짐 등

## 3. 필요 없는 검사 예외 사용은 피하자

- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외 던지기
- 복구가 가능하고 호출자가 그 처리를 해주길 바란다면 옵셔널을 반환해도 될지 고민
- 다음 페이지에서 Optional 참고

[8장 메서드](https://www.notion.so/8-0656622d97024558a85c466b1ec28c69)

## 4. 표준 예외를 사용

- 장점
    - 표준 규약을 따름 → 다른 프로그래머가 이해하기 쉬움
- 예시
    - IllegalArgumentException: 허용하지 않는 값이 인수로 들어왔을 때
    - IllegalStateException: 객체가 메서드를 수행하기에 적절하지 않은 상태일 때
    - NullPointException: null 이 허용되지 않는데 null이 들어왔을 때
    - UnsupportedOperationException: 호출한 메서드를 지원하지 않을 때

## 5. 추상화 수준에 맞는 예외를 던져라

- 예외 번역 (Exception translation)
    - 상위계층에서 저수준 예외를 잡아 자신의 추상화 수준에 맞는 상위 수준의 예외로 바꿔 던져야 한다
    - 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 노출하기 곤란하면 사용
    - 이 때 원인을 파악하기를 원한다면 예외 연쇄를 사용
- 예외 연쇄(Exception chaining)
    - 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 것
    - 상위 예외에 원인을 건네주어 원인 찾기에 도움을 줌
    - 대부분의 표준 예외는 예외 연쇄용 연산자 있음

## 6. 메서드가 던지는 모든 예외를 문서화 하라

- 모든 예외 문서화
- 방법
    - 검사 예외 → 자바독의 @throw 를 통해 문서화
    - 비검사 예외 → 다른 방법으로 문서화
- 왜 필요?
    - 다른사람이 클래스 사용할 때 효과적으로 올바르게 사용하는데 도움을 줌


## 7. 예외의 상세 메세지에 실패 관련 정보를 담아라

- 클라이언트가 무엇을 고쳐서 다시 요청해야하는지 알려주자
- 실패한 상황을 알려줄 수 있는 정보를 보여주자
- 예외 상황을 복구하는데 유용할 것이다

## 8. 가능한 한 실패 원자적으로 만들어라

- 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다
- 방법
    - 불변 객체로 설계 (메서드가 실패하면 새로운 객체 만들어 지지 않으니 기존 객체 그대로 있음)
    - 객체 바꾸는 코드 실행 전 if문으로 유효성 검사
    - 임시 복사본에서 작업하고, 성공하는 경우에만 기족 객체 대체
    - transactional 하게 (작업 도중 실패 가로채, 실패하면 이전 상태로 되돌리는)

## 9. 예외를 무시하지 말라

- try-catch 절에서 catch를 비워두지 말아라
- 그럼에도 불구하고 예외를 무시하기로 했다면 주석 남기기 + 예외 변수 이름도 ignored로 바꾸기