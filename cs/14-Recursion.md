# 재귀 vs 꼬리재귀

## 재귀

- 자기 자신을 호출하는 함수
- 자기 자신을 호출해서 하위 작업을 수행하는 경우

예시: 팩토리얼

```java
int factorial(int n) { 
    if (n === 1) { 
        return 1; 
    } 
    return n * factorial(n-1);
}
```

## 왜 사용할까?

- 반복코드 보다 짧고 작성하기 쉬워서
- 비슷한 하위 작업으로 정의될 수 있는 작업에 유용
- 변수를 여러개 만들 필요 없음

## 단점

- 지속적으로 함수 호출하면서 지역변수, 매개변수(입력값), 반환값을 모두 process stack에 저장해야함. 이런 과정은 선언한 변수의 값만 사용하는 반복문에 비해 더 많은 메모리를 사용하고, 속도 저하를 초래할 수 있다
- 함수호출 → 복귀를 위한 컨텍스트 스위칭에 비용이 많이 발생

## 재귀 vs 반복

### 재귀

- 기본 경우에 도달하면 종류
- 각 재귀 호출은 메모리에 부가 공간을 필요로함 (함수 호출)
- 무한 재귀 → 스택 오버플로우 초래

### 반복

- 조건이 거짓일때 종료
- 각 반복이 부가 공간을 필요로 하지 않는다
- 무한 루프 → 무한 반복 (추가 메모리 필요 없어서)

## 재귀 알고리즘 예

- 피보나치 수열, 팩토리얼 구하기
- 병합 정렬, 퀵 정렬
- 이진 검색
- 트리 탐색 등 트리문제들
- 그래프 탐색, 깊이 우선 탐색, 너비 우선 탐색
- 동적 계획법
- 분할 정복 알고리즘
- 하노이의 탑
- 백 트래킹 알고리즘

재귀를 이용한 [알고리즘 문제 풀어보기](https://ko.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/recursive-factorial)

---

## 단점 해결방법: 꼬리 재귀

- 재귀함수의 단점 (자기 자신을 호출한 뒤 결과를 기다리면서 생기는 콜 스택의 부하로 인한 메모리 낭비)을 해결
- 재귀 호출이 끝나는 시점에서 아무 일도 하지 않고 바로 결과를 반환하도록 하는 방법으로 함수의 상태유지 및 추가연산을 하지 않기에 스택오버플로우를 방지할 수 있음
- 팩토리얼 문제를 꼬리재귀로 푼 아래의 코드를 보면 return 에 n을 곱하는 연산이 없다
- 이렇게 반환분에 연산이 없도록 구현하면 꼬리재귀 최적화를 지원하여 자체적으로 재귀함수를 해석해 반복문으로 변형하여 실행한다